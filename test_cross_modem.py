#!/usr/bin/env python3
"""
Cross-Modem Interoperability Test
Tests Brain TX -> PhoenixNest RX using reference PCM files

This test validates that PhoenixNest can decode transmissions
generated by the Brain modem (Paul Brain's reference implementation).
"""

import socket
import time
import os
import glob
import sys

# PhoenixNest ports  
PN_CTRL = 4999
PN_DATA = 4998

# Reference PCM directory (Brain modem generated)
REFERENCE_PCM_DIR = os.path.join(os.path.dirname(__file__), "refrence_pcm")

# All 12 M110A modes
ALL_MODES = ['75S', '75L', '150S', '150L', '300S', '300L', 
             '600S', '600L', '1200S', '1200L', '2400S', '2400L']


def test_mode(mode, verbose=False):
    """Test a single mode: inject Brain PCM -> decode with PhoenixNest"""
    # Find matching reference PCM
    pattern = os.path.join(REFERENCE_PCM_DIR, f"tx_{mode}_*.pcm")
    files = glob.glob(pattern)
    if not files:
        return None, 'No PCM file', ''
    
    pcm_file = files[0]
    
    # Connect to PhoenixNest
    ctrl = socket.socket()
    ctrl.settimeout(10)
    ctrl.connect(('127.0.0.1', PN_CTRL))
    data = socket.socket()
    data.settimeout(10)
    data.connect(('127.0.0.1', PN_DATA))
    
    time.sleep(0.2)
    try:
        ctrl.recv(1024)
    except:
        pass
    
    # Set mode
    ctrl.send(f'CMD:DATA RATE:{mode}\n'.encode())
    time.sleep(0.2)
    ctrl.recv(4096)
    
    # Inject reference PCM
    ctrl.send(f'CMD:RXAUDIOINJECT:{pcm_file}\n'.encode())
    
    # Collect decoded data
    all_data = b''
    detected_mode = ''
    for i in range(200):
        time.sleep(0.05)
        
        try:
            data.setblocking(False)
            rx_data = data.recv(4096)
            if rx_data:
                all_data += rx_data
        except:
            pass
        finally:
            data.setblocking(True)
        
        try:
            ctrl.setblocking(False)
            resp = ctrl.recv(4096).decode()
            if 'STATUS:RX:' in resp and 'NO DCD' not in resp:
                for line in resp.split('\n'):
                    if 'STATUS:RX:' in line and 'NO DCD' not in line:
                        detected_mode = line.replace('STATUS:RX:', '').strip()
            if 'COMPLETE' in resp:
                break
        except:
            pass
        finally:
            ctrl.setblocking(True)
    
    ctrl.close()
    data.close()
    
    return all_data, detected_mode, pcm_file


def run_all_tests(modes=None, verbose=False):
    """Run cross-modem tests for specified modes (or all modes)"""
    if modes is None:
        modes = ALL_MODES
    
    print('Cross-Modem Interoperability Test')
    print('Brain TX (Reference PCM) -> PhoenixNest RX')
    print('=' * 70)
    print(f"{'Mode':6} | {'Status':6} | {'Detected Mode':20} | Decoded Text")
    print('-' * 70)
    
    results = []
    for mode in modes:
        data, detected, pcm_file = test_mode(mode, verbose)
        if data is None:
            status = 'SKIP'
            text = detected
        elif len(data) > 0:
            try:
                text = data.decode('latin-1')[:40]
            except:
                text = str(data[:40])
            if 'QUICK BROWN FOX' in text or 'THE QUICK' in text:
                status = 'PASS'
            else:
                status = 'DATA?'
        else:
            status = 'FAIL'
            text = 'No data received'
        
        results.append({
            'mode': mode,
            'status': status,
            'detected': detected,
            'text': text,
            'bytes': len(data) if data else 0
        })
        print(f'{mode:6} | {status:6} | {detected:20} | {text}')
    
    print('=' * 70)
    passed = sum(1 for r in results if r['status'] == 'PASS')
    print(f'Passed: {passed}/{len(modes)}')
    
    return results


if __name__ == "__main__":
    # Parse command line arguments
    modes = None
    if len(sys.argv) > 1:
        modes = [m.upper() for m in sys.argv[1:]]
    
    results = run_all_tests(modes)
    
    # Exit with error code if any tests failed
    passed = sum(1 for r in results if r['status'] == 'PASS')
    sys.exit(0 if passed == len(results) else 1)
